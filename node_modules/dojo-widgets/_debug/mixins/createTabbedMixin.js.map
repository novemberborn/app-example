{"version":3,"file":"createTabbedMixin.js","sourceRoot":"","sources":["createTabbedMixin.ts"],"names":[],"mappings":"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","sourcesContent":["import { h, VNode } from 'maquette/maquette';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport createDestroyable from 'dojo-compose/mixins/createDestroyable';\nimport { EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\nimport { StateChangeEvent } from 'dojo-compose/mixins/createStateful';\nimport { Handle } from 'dojo-core/interfaces';\nimport WeakMap from 'dojo-core/WeakMap';\nimport { CachedRenderMixin, CachedRenderState, CachedRenderParent } from './createCachedRenderMixin';\nimport { Closeable, CloseableState } from './createCloseableMixin';\nimport createContainerMixin, { ContainerMixin, ContainerChild, ContainerMixinState, ContainerMixinOptions } from './createContainerMixin';\n\nexport interface TabbedState extends ContainerMixinState { }\n\nexport interface TabbedChildState extends CachedRenderState, CloseableState {\n\t/**\n\t * Whether the current child is the active/visible child\n\t */\n\tactive?: boolean;\n\n\t/**\n\t * Should this child represent that it is in a changed state that is not persisted\n\t */\n\tchanged?: boolean; /* TODO: Implement this feature, currently it does not affect anything */\n}\n\nexport interface TabbedChild extends ContainerChild, Closeable<TabbedChildState>, CachedRenderMixin<TabbedChildState> {\n\t/**\n\t * The childs parent\n\t */\n\tparent?: CachedRenderParent;\n\n\ton(type: 'close', listener: EventedListener<CloseEvent>): Handle;\n\ton(type: 'statechange', listener: EventedListener<StateChangeEvent<TabbedChildState>>): Handle;\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport interface TabbedMixin<C extends TabbedChild, S extends TabbedState> extends ContainerMixin<C, S> {\n\t/**\n\t * Tag names used by sub parts of this widget\n\t */\n\ttagNames: {\n\t\ttabBar: string;\n\t\ttab: string;\n\t};\n\n\t/**\n\t * The currently active (visible) child\n\t */\n\tactiveChild: C;\n}\n\n/**\n * A utility function that sets the supplied tab as the active tab on the supplied tabbed mixin\n * @param tabbed The tabbed mixin to set the active child on\n * @param activeTab The tab to make active/visible\n */\nfunction setActiveTab(tabbed: TabbedMixin<TabbedChild, TabbedState>, activeTab: TabbedChild) {\n\tif (activeTab.parent === tabbed) {\n\t\ttabbed.children.forEach((tab) => {\n\t\t\tif (tab !== activeTab && tab.state.active) {\n\t\t\t\ttab.setState({ active: false });\n\t\t\t}\n\t\t});\n\t\tif (!activeTab.state.active) {\n\t\t\tactiveTab.setState({ active: true });\n\t\t}\n\t}\n}\n\n/**\n * Return the currently active tab, if no tab is active, the first tab will be made active\n * @param tabbed The tabbed mixin to return the active child for\n */\nfunction getActiveTab(tabbed: TabbedMixin<TabbedChild, TabbedState>): TabbedChild {\n\tlet activeTab = tabbed.children.find((tab) => tab.state.active);\n\t/* TODO: when a tab closes, instead of going back to the previous active tab, it will always\n\t * revert to the first tab, maybe it would be better to keep track of a stack of tabs? */\n\tif (!activeTab) {\n\t\tactiveTab = tabbed.children.first();\n\t}\n\tif (activeTab) {\n\t\tsetActiveTab(tabbed, activeTab);\n\t}\n\treturn activeTab;\n}\n\ninterface TabListeners {\n\t/**\n\t * The listener for when a tab is clicked on (selected)\n\t */\n\tonclickTabListener(evt: MouseEvent): boolean;\n\n\t/**\n\t * The listener for when the close button is clicked\n\t */\n\tonclickTabCloseListener(evt: MouseEvent): boolean;\n}\n\n/**\n * A weakmap of tabs and their listeners\n */\nconst tabListenersMap = new WeakMap<TabbedChild, TabListeners>();\n\n/**\n * A utility function that sets the listeners for a tab which are then passed in the generated VDom.  The function\n * returns a handle that can be used to clean up the listeners\n * @param tabbed The tabbed mixin that should be effected when the listeners fire\n * @param tab The tab that the listeners are referring to\n */\nfunction setTabListeners(tabbed: TabbedMixin<TabbedChild, TabbedState>, tab: TabbedChild): Handle {\n\t/* TODO: There is an edge case where if a child tab is moved from one tabbed panel to another without being destroyed */\n\ttabListenersMap.set(tab, {\n\t\tonclickTabListener(evt: MouseEvent): boolean {\n\t\t\tevt.preventDefault();\n\t\t\tsetActiveTab(tabbed, tab);\n\t\t\treturn true;\n\t\t},\n\t\tonclickTabCloseListener(evt: MouseEvent): boolean {\n\t\t\tevt.preventDefault();\n\t\t\ttab.close().then((result) => {\n\t\t\t\t/* while Maquette schedules a render on DOM events, close happens async, therefore we have to\n\t\t\t\t * invalidate the tabbed when resolved, otherwise the tab panel won't reflect the actual\n\t\t\t\t * children */\n\t\t\t\tif (result) {\n\t\t\t\t\ttabbed.invalidate();\n\t\t\t\t};\n\t\t\t});\n\t\t\treturn true;\n\t\t}\n\t});\n\treturn {\n\t\tdestroy() {\n\t\t\tconst tabListeners = tabListenersMap.get(tab);\n\t\t\tif (tabListeners) {\n\t\t\t\ttabListenersMap.delete(tab);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Return (or initilize) the tab listeners for a tab\n * @param tabbed The tabbed mixin that the listerns refer to\n * @param tab The tab that the listeners should be retrieved for\n */\nfunction getTabListeners(tabbed: TabbedMixin<TabbedChild, TabbedState>, tab: TabbedChild): TabListeners {\n\tif (!tabListenersMap.has(tab)) {\n\t\t/* When the tab is destroyed, it will remove its listeners */\n\t\ttab.own(setTabListeners(tabbed, tab));\n\t}\n\treturn tabListenersMap.get(tab);\n}\n\nexport interface TabbedMixinFactory extends ComposeFactory<TabbedMixin<TabbedChild, ContainerMixinOptions<TabbedState>>, ContainerMixinOptions<TabbedState>> {}\n\nconst childrenNodesCache = new WeakMap<TabbedMixin<TabbedChild, TabbedState>, VNode[]>();\n\nconst createTabbedMixin = createContainerMixin\n\t.mixin({\n\t\tmixin: {\n\t\t\ttagName: 'dojo-panel-mixin',\n\t\t\ttagNames: {\n\t\t\t\ttabBar: 'ul',\n\t\t\t\ttab: 'li'\n\t\t\t},\n\n\t\t\tget activeChild(): TabbedChild {\n\t\t\t\treturn getActiveTab(this);\n\t\t\t},\n\n\t\t\tset activeChild(value: TabbedChild) {\n\t\t\t\tsetActiveTab(this, value);\n\t\t\t},\n\n\t\t\tgetChildrenNodes(): (VNode | string)[] {\n\t\t\t\tconst tabbed: TabbedMixin<TabbedChild, TabbedState> = this;\n\t\t\t\tconst activeTab = getActiveTab(tabbed);\n\n\t\t\t\tfunction getTabChildVNode(tab: TabbedChild): (VNode | string)[] {\n\t\t\t\t\tconst tabListeners = getTabListeners(tabbed, tab);\n\t\t\t\t\tconst nodes = [ h('div.tab-label', { onclick: tabListeners.onclickTabListener }, [ tab.state.label ]) ];\n\t\t\t\t\tif (tab.state.closeable) {\n\t\t\t\t\t\tnodes.push(h('div.tab-close', { onclick: tabListeners.onclickTabCloseListener }, [ 'X' ]));\n\t\t\t\t\t}\n\t\t\t\t\treturn nodes;\n\t\t\t\t}\n\n\t\t\t\t/* We need to generate a set of VDom the represents the buttons */\n\t\t\t\t/* TODO: Allow the location of the tab bar to be set (top/left/bottom/right) */\n\t\t\t\tconst tabs: VNode[] = [];\n\t\t\t\tlet childrenNodes = childrenNodesCache.get(tabbed);\n\n\t\t\t\t/* Best to discard the childrenNodes array if the sizes don't match, otherwise\n\t\t\t\t * we can get some vdom generation issues when adding or removing tabs */\n\t\t\t\tif (!childrenNodes || childrenNodes.length !== tabbed.children.size) {\n\t\t\t\t\tchildrenNodes = Array(tabbed.children.size);\n\t\t\t\t\tchildrenNodesCache.set(tabbed, childrenNodes);\n\t\t\t\t}\n\n\t\t\t\ttabbed.children.forEach((tab, key) => {\n\t\t\t\t\tconst isActiveTab = tab === activeTab;\n\t\t\t\t\tif (isActiveTab || (childrenNodes[key] && childrenNodes[key].properties.classes['visible'])) {\n\t\t\t\t\t\ttab.invalidate();\n\t\t\t\t\t\tconst tabVNode = tab.render();\n\t\t\t\t\t\ttabVNode.properties.classes['visible'] = isActiveTab;\n\t\t\t\t\t\tchildrenNodes[key] = tabVNode;\n\t\t\t\t\t}\n\t\t\t\t\t/* else, this tab isn't active and hasn't been previously rendered */\n\n\t\t\t\t\ttabs.push(h(tabbed.tagNames.tab, { key: tab, classes: { active: isActiveTab } }, getTabChildVNode(tab)));\n\t\t\t\t});\n\n\t\t\t\treturn [ h(tabbed.tagNames.tabBar, tabs), h('div.panels', childrenNodes) ];\n\t\t\t}\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createDestroyable,\n\t\tinitialize(instance: TabbedMixin<TabbedChild, TabbedState>) {\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tchildrenNodesCache.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}) as TabbedMixinFactory;\n\nexport default createTabbedMixin;\n"]}