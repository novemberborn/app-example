(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", 'maquette/maquette', 'dojo-compose/mixins/createDestroyable', 'immutable/immutable', 'dojo-core/WeakMap', './createContainerMixin'], factory);
    }
})(function (require, exports) {
    "use strict";
    var maquette_1 = require('maquette/maquette');
    var createDestroyable_1 = require('dojo-compose/mixins/createDestroyable');
    var immutable_1 = require('immutable/immutable');
    var WeakMap_1 = require('dojo-core/WeakMap');
    var createContainerMixin_1 = require('./createContainerMixin');
    /**
     * A utility function that sets the supplied tab as the active tab on the supplied tabbed mixin
     * @param tabbed The tabbed mixin to set the active child on
     * @param activeTab The tab to make active/visible
     */
    function setActiveTab(tabbed, activeTab) {
        if (activeTab.parent === tabbed) {
            tabbed.children.forEach(function (tab) {
                if (tab !== activeTab && tab.state.active) {
                    tab.setState({ active: false });
                }
            });
            if (!activeTab.state.active) {
                activeTab.setState({ active: true });
            }
        }
    }
    /**
     * Return the currently active tab, if no tab is active, the first tab will be made active
     * @param tabbed The tabbed mixin to return the active child for
     */
    function getActiveTab(tabbed) {
        var activeTab = tabbed.children.find(function (tab) { return tab.state.active; });
        /* TODO: when a tab closes, instead of going back to the previous active tab, it will always
         * revert to the first tab, maybe it would be better to keep track of a stack of tabs? */
        if (!activeTab) {
            activeTab = tabbed.children.first();
        }
        if (activeTab) {
            setActiveTab(tabbed, activeTab);
        }
        return activeTab;
    }
    /**
     * A weakmap of tabs and their listeners
     */
    var tabListenersMap = new WeakMap_1.default();
    /**
     * A utility function that sets the listeners for a tab which are then passed in the generated VDom.  The function
     * returns a handle that can be used to clean up the listeners
     * @param tabbed The tabbed mixin that should be effected when the listeners fire
     * @param tab The tab that the listeners are referring to
     */
    function setTabListeners(tabbed, tab) {
        /* TODO: There is an edge case where if a child tab is moved from one tabbed panel to another without being destroyed */
        tabListenersMap.set(tab, {
            onclickTabListener: function (evt) {
                evt.preventDefault();
                setActiveTab(tabbed, tab);
                return true;
            },
            onclickTabCloseListener: function (evt) {
                evt.preventDefault();
                tab.close().then(function (result) {
                    /* while Maquette schedules a render on DOM events, close happens async, therefore we have to
                     * invalidate the tabbed when resolved, otherwise the tab panel won't reflect the actual
                     * children */
                    if (result) {
                        tabbed.invalidate();
                    }
                    ;
                });
                return true;
            }
        });
        return {
            destroy: function () {
                var tabListeners = tabListenersMap.get(tab);
                if (tabListeners) {
                    tabListenersMap.delete(tab);
                }
            }
        };
    }
    /**
     * Return (or initilize) the tab listeners for a tab
     * @param tabbed The tabbed mixin that the listerns refer to
     * @param tab The tab that the listeners should be retrieved for
     */
    function getTabListeners(tabbed, tab) {
        if (!tabListenersMap.has(tab)) {
            /* When the tab is destroyed, it will remove its listeners */
            tab.own(setTabListeners(tabbed, tab));
        }
        return tabListenersMap.get(tab);
    }
    var childrenNodesCache = new WeakMap_1.default();
    var tabbedList = immutable_1.List();
    var createTabbedMixin = createContainerMixin_1.default
        .mixin({
        mixin: {
            tagName: 'dojo-panel-mixin',
            tagNames: {
                tabBar: 'ul',
                tab: 'li'
            },
            get activeChild() {
                return getActiveTab(this);
            },
            set activeChild(value) {
                setActiveTab(this, value);
            },
            getChildrenNodes: function () {
                var tabbed = this;
                var activeTab = getActiveTab(tabbed);
                function getTabChildVNode(tab) {
                    var tabListeners = getTabListeners(tabbed, tab);
                    var nodes = [maquette_1.h('div.tab-label', { onclick: tabListeners.onclickTabListener }, [tab.state.label])];
                    if (tab.state.closeable) {
                        nodes.push(maquette_1.h('div.tab-close', { onclick: tabListeners.onclickTabCloseListener }, ['X']));
                    }
                    return nodes;
                }
                /* We need to generate a set of VDom the represents the buttons */
                /* TODO: Allow the location of the tab bar to be set (top/left/bottom/right) */
                var tabs = [];
                var childrenNodes = childrenNodesCache.get(tabbed);
                /* Best to discard the childrenNodes array if the sizes don't match, otherwise
                 * we can get some vdom generation issues when adding or removing tabs */
                if (!childrenNodes || childrenNodes.length !== tabbed.children.size) {
                    childrenNodes = Array(tabbed.children.size);
                    childrenNodesCache.set(tabbed, childrenNodes);
                }
                tabbed.children.forEach(function (tab, key) {
                    var isActiveTab = tab === activeTab;
                    if (isActiveTab || (childrenNodes[key] && childrenNodes[key].properties.classes['visible'])) {
                        tab.invalidate();
                        var tabVNode = tab.render();
                        tabVNode.properties.classes['visible'] = isActiveTab;
                        childrenNodes[key] = tabVNode;
                    }
                    /* else, this tab isn't active and hasn't been previously rendered */
                    tabs.push(maquette_1.h(tabbed.tagNames.tab, {
                        key: tab,
                        classes: { active: isActiveTab },
                        'data-tab-id': (tabbed.state.id || tabbedList.indexOf(tabbed)) + "-" + (tab.state.id || key)
                    }, getTabChildVNode(tab)));
                });
                return [maquette_1.h(tabbed.tagNames.tabBar, tabs), maquette_1.h('div.panels', childrenNodes)];
            }
        }
    })
        .mixin({
        mixin: createDestroyable_1.default,
        initialize: function (instance) {
            tabbedList = tabbedList.push(instance);
            instance.own({
                destroy: function () {
                    childrenNodesCache.delete(instance);
                    tabbedList = tabbedList.delete(tabbedList.indexOf(instance));
                }
            });
        }
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createTabbedMixin;
});
//# sourceMappingURL=../_debug/mixins/createTabbedMixin.js.map